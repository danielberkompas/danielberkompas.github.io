<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Daniel Berkompas">
<meta name="description" content="Describe your website">
<meta name="generator" content="Hugo 0.47.1" />
<title>SEO Tags In Phoenix</title>
<link rel="shortcut icon" href="https://blog.danielberkompas.com/images/favicon.ico">
<link rel="stylesheet" href="https://blog.danielberkompas.com/css/style.css">
<link rel="stylesheet" href="https://blog.danielberkompas.com/css/highlight.css">

<link rel="stylesheet" href="https://blog.danielberkompas.com/css/overrides.css">



<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css">



<link href="https://blog.danielberkompas.com/index.xml" rel="alternate" type="application/rss+xml" title="Bits &amp; Sundry" />


<meta property="og:title" content="SEO Tags In Phoenix" />
<meta property="og:description" content="Public facing websites need to have some basic search engine optimization (SEO) tags, such as &lt;title&gt; and &lt;meta name=&quot;description&quot;&gt;. In Rails, you could achieve this pretty simply by putting a yield :head tag in the appropriate layout.

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.danielberkompas.com/2016/01/28/seo-tags-in-phoenix/" /><meta property="article:published_time" content="2016-01-28T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2016-01-28T00:00:00&#43;00:00"/>


<meta itemprop="name" content="SEO Tags In Phoenix">
<meta itemprop="description" content="Public facing websites need to have some basic search engine optimization (SEO) tags, such as &lt;title&gt; and &lt;meta name=&quot;description&quot;&gt;. In Rails, you could achieve this pretty simply by putting a yield :head tag in the appropriate layout.

">


<meta itemprop="datePublished" content="2016-01-28T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2016-01-28T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="1172">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SEO Tags In Phoenix"/>
<meta name="twitter:description" content="Public facing websites need to have some basic search engine optimization (SEO) tags, such as &lt;title&gt; and &lt;meta name=&quot;description&quot;&gt;. In Rails, you could achieve this pretty simply by putting a yield :head tag in the appropriate layout.

"/>
<meta name="twitter:site" content="@https://www.twitter.com/dberkom"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='https://blog.danielberkompas.com'> <span class="arrow">←</span>Home</a>
	

	
 		<a href='/projects'>Projects</a>
  	
 		<a href='/about'>About</a>
  	
 		<a href='/tags'>Tags</a>
  	

	
		<a class="cta" href="https://blog.danielberkompas.com/index.xml">Subscribe</a>
	
</nav>

    <section id="wrapper">
        
        
<article class="post">
  <header>
    <h1>SEO Tags In Phoenix</h1>
    <h2 class="subtitle"></h2>
    <h2 class="headline">
      January 28, 2016
      <br> 
    </h2>
  </header>
  <section id="post-body">
    <p>Public facing websites need to have some basic search engine optimization (SEO) tags, such as <code>&lt;title&gt;</code> and <code>&lt;meta name=&quot;description&quot;&gt;</code>. In Rails, you could achieve this pretty simply by putting a <code>yield :head</code> tag in the appropriate layout.</p>

<p></p>

<pre><code class="language-erb">&lt;head&gt;
  &lt;%= yield :head %&gt;
&lt;/head&gt;
</code></pre>

<p>Inside any of your views, you could then use <code>content_for</code> to populate this section:</p>

<pre><code class="language-erb">&lt;% content_for :head do %&gt;
  &lt;title&gt;My Awesome Site&lt;/title&gt;
  &lt;meta name=&quot;description&quot; content=&quot;...&quot; /&gt;
&lt;% end %&gt;

&lt;!-- More view content here... ---&gt;
</code></pre>

<p>This is nice, in that it keeps the HTML all together in more or less the same place. In <a href="https://phoenixframework.org">Phoenix</a>, this has to be done differently.</p>

<h2 id="how-phoenix-is-different">How Phoenix is Different</h2>

<p>In Phoenix, your layout is rendered <em>before</em> your page template is rendered. Take this layout, for example:</p>

<pre><code class="language-erb">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render @view_module, @view_template, assigns %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Because Phoenix renders templates as functions, by the time your <code>@view_template</code> is rendered, the <code>&lt;head&gt;</code> is already rendered. So, there&rsquo;s nothing that your view template can do to inject content back up into <code>&lt;head&gt;</code>. The <code>content_for</code> approach won&rsquo;t work.</p>

<p>I think there are at least four approaches to dealing with this.</p>

<h2 id="1-render-existing-2">1. <code>render_existing/2</code></h2>

<p>Both Chris McCord and José Valim mentioned <code>render_existing/2</code> when they saw this post. I knew about it, (I believe it was one of my questions on IRC that prompted its creation, actually) and while I don&rsquo;t necessarily prefer it, it really should be mentioned here.</p>

<p>To use <code>render_existing</code> for your meta tags, you&rsquo;d change your layout to look like this:</p>

<pre><code class="language-erb">&lt;html&gt;
  &lt;head&gt;
    &lt;%= render_existing(@view_module, &quot;meta.&quot; &lt;&gt; @view_template, assigns) ||
        render(MyApp.LayoutView, &quot;meta.html&quot;, assigns) %&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render @view_module, @view_template, assigns %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>The <code>render_existing</code> function will silently render nothing if the given template doesn&rsquo;t exist. The alternate <code>render</code> call will take over if you don&rsquo;t specify a meta file for your view/action, and will render the defaults.</p>

<p>Anyway, after modifying your layout, you could then create a <code>meta.index.html.eex</code> file in your view&rsquo;s template folder that contains whatever content you want:</p>

<pre><code>&lt;title&gt;My Awesome App&lt;/title&gt;
&lt;meta name=&quot;description&quot; content=&quot;...&quot; /&gt;
</code></pre>

<p>This feels a bit more like Rails, but you end up with an extra file for each action in your controller, which feels a little odd.</p>

<pre><code>meta.edit.html.eex
meta.index.html.eex
meta.new.html.eex
edit.html.eex
index.html.eex
new.html.eex
</code></pre>

<p>You can avoid this by defining these templates as functions in your view rather than template files:</p>

<pre><code class="language-elixir">def render(&quot;meta.index.html&quot;, _assigns) do
  ~E{
    &lt;title&gt;My Awesome App&lt;/title&gt;
    &lt;meta type=&quot;description&quot; content=&quot;...&quot; /&gt;
  }
end
</code></pre>

<p>The <code>~E</code> sigil allows you to write EEX code inline in your view. This is fine, but it still can get a little messy looking with long meta descriptions, and you end up with a lot of function definitions.</p>

<p>I personally think this is likely to confuse the other devs on the projects I work on, so I&rsquo;ve chosen not to establish it as the &ldquo;standard&rdquo; way at <a href="http://infinite.red">Infinite Red</a>. It is definitely a valid option though, and seems to be the &ldquo;official&rdquo; way.</p>

<h2 id="2-assigns-in-each-controller-action">2. Assigns in Each Controller Action</h2>

<p>The second approach modifies the layout to look like this:</p>

<pre><code class="language-erb">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= @title %&gt;&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&lt;%= @meta %&gt;&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render @view_module, @view_template, assigns %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Then, in each controller action in the app, the developer must specify <code>title</code> and <code>meta</code> assigns:</p>

<pre><code class="language-elixir">def index(conn, _params) do
  conn
  |&gt; assign(:title, &quot;My Awesome App&quot;)
  |&gt; assign(:meta, &quot;...&quot;)
  |&gt; render(&quot;index.html&quot;)
end
</code></pre>

<p>There are a few downsides to this. First, the title and meta description can dominate the controller action, making it harder to see the business logic. Second, it can easily end up being pretty ugly if you don&rsquo;t put it all on one line:</p>

<pre><code class="language-elixir">def index(conn, _params) do
  conn
  |&gt; assign(:title, &quot;My Awesome App&quot;)
  |&gt; assign(:meta, &quot;&quot;&quot;
     Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam feugiat 
     nibh ligula. Maecenas egestas nibh cursus erat sodales, vitae congue nisi
     tempus. Nam mattis et velit eu lacinia.
     &quot;&quot;&quot;)
  |&gt; render(&quot;index.html&quot;)
end
</code></pre>

<p>I think we can do better.</p>

<h2 id="3-delegated-functions">3. Delegated Functions</h2>

<p>Another alternative I&rsquo;ve seen is to delegate to functions on your view module, like this:</p>

<pre><code class="language-erb">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= @view_module.title(@view_template, assigns) %&gt;&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&lt;%= @view_module.meta(@view_template, assigns) %&gt;&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render @view_module, @view_template, assigns %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Then, in your view module, you can define different titles or meta descriptions for different layouts, or set a default.</p>

<pre><code class="language-elixir">defmodule MyApp.PageView do
  use MyApp.Web, :view
  
  def title(&quot;index.html&quot;, _assigns), do: &quot;My Awesome App&quot;
  def title(_other, _assigns), do: &quot;Default Title&quot;
  
  def meta(&quot;index.html&quot;, _assigns), do: &quot;...&quot;
  def meta(_other, _assigns), do: &quot;Default Meta&quot;
end
</code></pre>

<p>This is pretty similar to the first approach outlined above.</p>

<p>If you didn&rsquo;t want to have to define these functions on every view, you could create a mixin that would define default implementations of these <code>title</code> and <code>meta</code> functions.</p>

<pre><code class="language-elixir">defmodule MyApp.SEO.Defaults do
  defmacro __using__(_) do
    quote do
      def title(_other, _assigns), do: &quot;Default Title&quot;
      def meta(_other, _assigns), do: &quot;Default Meta&quot;
      
      defoverridable [title: 2, meta: 2]
    end
  end
end
</code></pre>

<p>Then, <code>use</code> this module in your <code>web/web.ex</code> to make it affect all views.</p>

<pre><code class="language-elixir">def view do
  quote do
    # ...
    use MyApp.SEO.Defaults
  end
end
</code></pre>

<p>This approach has the advantage of cleaning up the controller, but I think it&rsquo;s a bit less clear where the titles and meta descriptions are being generated, and it&rsquo;s not clearly better than the <code>render_existing</code> approach.</p>

<h2 id="4-use-a-plug">4. Use a Plug</h2>

<p>A huge number of problems can be solved with Plug, so today, I thought I would try to use it to solve this problem. It&rsquo;s pretty simple to create a custom plug for this:</p>

<pre><code class="language-elixir">defmodule MyApp.SEO.Plug do
  def put_seo(%{private: %{phoenix_action: action}} = conn, settings) do
    settings = settings[action] || []

    conn
    |&gt; assign(:title, settings[:title])
    |&gt; assign(:meta, settings[:meta])
  end
end
</code></pre>

<p>The plug takes a &ldquo;settings&rdquo; argument, which we read from to determine what the <code>title</code> and <code>meta</code> assigns should be. I just include it in the <code>controller</code> section of <code>web/web.ex</code>:</p>

<pre><code class="language-elixir">def controller do
  quote do
    # ...
    import MyApp.SEO.Plug
  end
end
</code></pre>

<p>And then I can use it in my controllers, like so:</p>

<pre><code class="language-elixir">defmodule MyApp.PageController do
  use MyApp.Web, :controller
  
  @meta %{
    index: %{
      title: &quot;My Awesome App&quot;,
      meta: &quot;&quot;&quot;
      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam feugiat 
      nibh ligula. Maecenas egestas nibh cursus erat sodales, vitae congue nisi
      tempus. Nam mattis et velit eu lacinia.
      &quot;&quot;&quot;
    },
    contact: %{
      title: &quot;Contact Us&quot;
      meta: &quot;...&quot;
    }
  }
  
  plug :put_seo, @meta
  
  def index(conn, _params) do
    # ...
  end
  
  def contact(conn, _params) do
    # ...
  end
end
</code></pre>

<p>And my layout looks like this:</p>

<pre><code class="language-erb">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;&lt;%= assigns[:title] || &quot;Default&quot; %&gt;&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;&lt;%= assigns[:meta] || &quot;Default&quot; %&gt;&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;%= render @view_module, @view_template, assigns %&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>While I&rsquo;m not completely happy with it, (it would be nice to get all that text out of the controller), I think this is pretty clear. The controller actions are also uncluttered, which is a plus.</p>

<h2 id="other-approaches">Other Approaches</h2>

<p>I&rsquo;m pretty sure you could create a plug that used the <a href="http://hexdocs.pm/gettext/Gettext.html">Gettext</a> API to extract all the strings out to .po files. I&rsquo;m just not sure that&rsquo;s worth the added complexity and explaining to new developers.</p>

<p>I hope you found this helpful!</p>
  </section>
</article>

<footer id="post-meta" class="clearfix">
  <a href="https://twitter.com/dberkom">
    <img class="avatar" src="/img/avatar.png">
    <div>
      <span class="dark">Daniel Berkompas</span>
      <span>Full-stack software engineer at <a href="https://infinite.red">Infinite Red</a></span>
    </div>
    </a>
  <section id="sharing">
    <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fblog.danielberkompas.com%2f2016%2f01%2f28%2fseo-tags-in-phoenix%2f - SEO%20Tags%20In%20Phoenix by @dberkom"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

  </section>
</footer>

<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "dberkomcodeblog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a> <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/2018/08/22/elixirconf-2018-talk-picks/">ElixirConf 2018 Talk Picks<aside class="dates">Aug 22 2018</aside></a>
        </li>
    
        <li>
            <a href="/2018/03/17/flexible-design-with-adapters/">Flexible Design with Adapters<aside class="dates">Mar 17 2018</aside></a>
        </li>
    
        <li>
            <a href="/2017/09/30/why-your-software-projects-fail/">Why Your Software Projects Fail<aside class="dates">Sep 30 2017</aside></a>
        </li>
    
        <li>
            <a href="/2017/01/17/reusable-templates-in-phoenix/">Reusable Templates in Phoenix<aside class="dates">Jan 17 2017</aside></a>
        </li>
    
        <li>
            <a href="/2016/09/27/ecto-multi-services/">Replace Callbacks with Ecto.Multi<aside class="dates">Sep 27 2016</aside></a>
        </li>
    
        <li>
            <a href="/2016/04/23/multidimensional-arrays-in-elixir/">Multidimensional Arrays in Elixir<aside class="dates">Apr 23 2016</aside></a>
        </li>
    
        <li>
            <a href="/2016/04/05/background-jobs-in-phoenix/">Background Jobs in Phoenix<aside class="dates">Apr 5 2016</aside></a>
        </li>
    
        <li>
            <a href="/2015/12/08/use-gen-event-with-ecto-callbacks/">Using GenEvent With Ecto Callbacks<aside class="dates">Dec 8 2015</aside></a>
        </li>
    
        <li>
            <a href="/2015/10/15/why-im-checking-out-graphql/">Why I&#39;m Checking Out GraphQL<aside class="dates">Oct 15 2015</aside></a>
        </li>
    
        <li>
            <a href="/2015/09/25/announcing-learn-elixir-tv/">Announcing LearnElixir.tv<aside class="dates">Sep 25 2015</aside></a>
        </li>
    
</ul>
 

        <footer id="footer">
    
        <div id="social">

	
	
    <a class="symbol" href="https://www.github.com/danielberkompas">
        <i class="fa fa-github"></i>
    </a>
    
    <a class="symbol" href="https://www.twitter.com/dberkom">
        <i class="fa fa-twitter"></i>
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2018 Daniel Berkompas
    
    </p>
</footer>

    </section>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://blog.danielberkompas.com/js/main.js"></script>
<script src="https://blog.danielberkompas.com/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-23392891-3', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
