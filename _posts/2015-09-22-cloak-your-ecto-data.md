---
layout: "post"
author: "Daniel Berkompas"
title: "Cloak Your Ecto Data"
---

I've written previously about how to encrypt your data when you are using
[Ecto][ecto], here:

[Encrypting Data With Ecto](http://blog.danielberkompas.com/elixir/security/2015/07/03/encrypting-data-with-ecto.html)  
[Changing Your Ecto Encryption Key](http://blog.danielberkompas.com/elixir/security/2015/07/09/changing-your-ecto-encryption-key.html)

After deciding to use encryption for one of my personal projects, I decided that
the techniques I wrote about should be built into a [Hex][hex] package. With
that in mind...

## Presenting Cloak

I'm pleased to present [Cloak][cloak], a simple encryption package designed to
be used with Ecto. It implements all the ideas I've written about, and then
some. It supports:

- Seamless encryption/decryption of model fields
- Zero-downtime migrations to new keys _and cipher suites_
- Multiple ciphers in use at once (though only one will be used for encryption)

### Configuration

It's simple to use. Select a cipher (there's only one currently, AES CTR), and
then configure it in your `config/config.exs`:

```elixir
config :cloak, Cloak.AES.CTR,
  tag: "AES",
  default: true,
  keys: [
    %{tag: <<1>>, key: :base64.decode("your key here"), default: true}
  ]
```

The `:tag` for the given cipher module will be prepended to any ciphertext 
generated by that module. `:default` controls whether this cipher should be the
default for encrypting new values, and the `:keys` array holds a list of keys 
to use.

Each key also has a `:tag`, which will become part of each ciphertext, and a
`:default` setting to control whether it should be used for new encryption.

You can then use the `Cloak.encrypt/1` and `Cloak.decrypt/1` functions directly 
to encrypt and decrypt values using the default cipher module:

```elixir
# Delegates encryption work to Cloak.AES.CTR.encrypt/1
Cloak.encrypt("Hello, World!")
# => <<65, 69, 83, 1, 235, 128, 59, ...>>

Cloak.encrypt("Hello, World!")
|> Cloak.decrypt
# => "Hello, World!"
```

`Cloak` is able to distinguish between ciphertext based on the `:tag`s. For
example, when using the `Cloak.AES.CTR` cipher module, `Cloak` will generate
ciphertext in this format:

| Cipher Tag <br /><small>(n bytes)</small> | Key Tag <br /><small>(1 byte)</small> | IV <br /><small>(16 bytes)</small> | Ciphertext <br /><small>(n bytes)</small> |
| -------                                   | -------                               | ------                             | ------                                    |
| "AES"                                     | 1                                     | <<235, 128, 59, 167, 97, ...>>     | <<89, 228, 1, 111, 197, 201, ...>>        |

When you call `Cloak.decrypt/1`, `Cloak` will use the cipher tag to determine 
which module created the ciphertext, and will then pass _the rest_ of the 
binary to that module's `decrypt/1` function for decryption.

This allows `Cloak` to continue to decrypt old values flawlessly, even if you've
set up a new `:default` encryption module or key.

## Ecto Integration

It's easy to integrate `Cloak` with Ecto. Add the field you intend to encrypt to
your database; it should be a `:binary` field.

```elixir
defmodule User do
  use Ecto.Model

  schema "users" do
    field :name, :binary
  end
end
```

Then, replace the `:binary` type with `Cloak.EncryptedBinaryField`:

```elixir
defmodule User do
  use Ecto.Model

  schema "users" do
    field :name, Cloak.EncryptedBinaryField
  end
end
```

And that's it! The `:name` field will be transparently encrypted and decrypted
with the cipher module you configured.

Cloak supports string fields, map fields, integer fields, float fields, and
SHA256 hash fields as of this writing. I'm definitely open to contributions!

## Migrating to a New Key or Cipher

Because Cloak tags every piece of ciphertext with metadata, you don't _have_ to
do anything when you switch to a new key. Old data will be gradually converted
to the new key or cipher as your app is used.

At the very least, this means that your app can stay up during the transition.
However, you usually will want to proactively migrate rows to the new key. To do
so, you will need to track which encryption configuration was used to encrypt
each row, so that you can know which rows need to be migrated.

Add an `:encryption_version` field to your module, with a `:binary` type, and
`use` the `Cloak.Model` module.

```diff
defmodule User do
  use Ecto.Model
+ use Cloak.Model, :encryption_version

  schema "users" do
    field :name, Cloak.EncryptedBinaryField
+   field :encryption_version, :binary
  end
end
```

This will set up `before_insert` and `before_update` hooks on your model to save
metadata about the encryption that was used to encrypt that module in the
`:encryption_version` field.

Next, configure your `:migration` settings in `config/config.exs`:

```elixir
config :cloak, :migration,
  repo: Repo,
  models: [User] # A list of modules that you want to migrate
```

Then, simply run the following mix task, and all the rows in your database will
be proactively migrated to the new `:default` encryption configuration!

```bash
$ mix cloak.migrate
```

## Conclusion

I hope this package will be useful to others out there. If you have any
suggestions or ideas, please let me know over [on Github][cloak].

<hr />

#### More Documentation?

See the [Hex documentation for Cloak](http://hexdocs.pm/cloak) for more in-depth
information. 

#### Contributing

I realize that only supporting AES CTR encryption is somewhat limiting. If you'd 
like to contribute more encryptors, I'm accepting PRs at 
[Cloak's Github repo][cloak].

[hex]: http://hex.pm
[cloak]: https://github.com/danielberkompas/cloak
[ecto]: https://github.com/elixir-lang/ecto
